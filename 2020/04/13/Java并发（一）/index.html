<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/EdwardLee50/EdwardLee50.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/EdwardLee50/EdwardLee50.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/EdwardLee50/EdwardLee50.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/EdwardLee50/EdwardLee50.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/EdwardLee50/EdwardLee50.github.io/css/main.css">


<link rel="stylesheet" href="/EdwardLee50/EdwardLee50.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/EdwardLee50/EdwardLee50.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="并发编程并发编程可以总结为三个核心问题：分工、同步、互斥。 分工指的是如何高效地拆解任务并分配给线程  &#x3D;&#x3D;&gt;  Fork&#x2F;Join 框架 同步指的是线程之间如何协作  &#x3D;&#x3D;&gt;  CountDownLatch 就是一种典型的同步方式 互斥则是保证同一时刻只允许一个线程访问共享资源  &#x3D;&#x3D;&gt; 可重入锁则是一种互斥手段">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发摘要笔记（一）">
<meta property="og:url" content="https://github.com/EdwardLee50/EdwardLee50.github.io/2020/04/13/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="EdwardLee50&#39;s Blog">
<meta property="og:description" content="并发编程并发编程可以总结为三个核心问题：分工、同步、互斥。 分工指的是如何高效地拆解任务并分配给线程  &#x3D;&#x3D;&gt;  Fork&#x2F;Join 框架 同步指的是线程之间如何协作  &#x3D;&#x3D;&gt;  CountDownLatch 就是一种典型的同步方式 互斥则是保证同一时刻只允许一个线程访问共享资源  &#x3D;&#x3D;&gt; 可重入锁则是一种互斥手段">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211108210517043.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211108210706017.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211108213443197.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/201410311002063.png">
<meta property="article:published_time" content="2020-04-13T09:01:37.489Z">
<meta property="article:modified_time" content="2020-04-13T09:06:13.207Z">
<meta property="article:author" content="EdwardLee50">
<meta property="article:tag" content="java,并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211108210517043.png">

<link rel="canonical" href="https://github.com/EdwardLee50/EdwardLee50.github.io/2020/04/13/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发摘要笔记（一） | EdwardLee50's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/EdwardLee50/EdwardLee50.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EdwardLee50's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/EdwardLee50/EdwardLee50.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/EdwardLee50/EdwardLee50.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/EdwardLee50/EdwardLee50.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/EdwardLee50/EdwardLee50.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/EdwardLee50/EdwardLee50.github.io/2020/04/13/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/EdwardLee50/EdwardLee50.github.io/images/avatar.png">
      <meta itemprop="name" content="EdwardLee50">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EdwardLee50's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发摘要笔记（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">

              

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-13 17:01:37 / 修改时间：17:06:13" itemprop="dateCreated datePublished" datetime="2020-04-13T17:01:37+08:00">2020-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/EdwardLee50/EdwardLee50.github.io/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/EdwardLee50/EdwardLee50.github.io/categories/java/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p><strong>并发编程可以总结为三个核心问题：分工、同步、互斥。</strong></p>
<p><strong>分工</strong>指的是如何高效地拆解任务并分配给线程  ==&gt;  Fork/Join 框架</p>
<p><strong>同步</strong>指的是线程之间如何协作  ==&gt;  CountDownLatch 就是一种典型的同步方式</p>
<p><strong>互斥</strong>则是保证同一时刻只允许一个线程访问共享资源  ==&gt; 可重入锁则是一种互斥手段</p>
<span id="more"></span>
<h3 id="1-分工"><a href="#1-分工" class="headerlink" title="1. 分工"></a>1. 分工</h3><p>任务分解和分工对于项目成败非常关键，不过在并发领域里，分工更重要，它直接决定了并发程序的性能。</p>
<p>Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是一种分工方法。</p>
<p>除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 - 消费者、Thread-Per-Message、Worker Thread 模式等都是用来指导你如何分工的。</p>
<h3 id="2-同步-协作"><a href="#2-同步-协作" class="headerlink" title="2. 同步/协作"></a>2. 同步/协作</h3><p><strong>一个线程执行完了一个任务，如何通知执行后续任务的线程开工</strong></p>
<p>工作中遇到的线程协作问题，基本上都可以描述为：<strong>当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行</strong>。</p>
<p>解决协作问题的核心技术是<strong>管程</strong>。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决互斥问题。可以这么说，<strong>管程是解决并发问题的万能钥匙</strong>。</p>
<p>协作一般是和分工相关的。Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是分工方法，但同时也能解决线程协作的问题。例如，用 Future 可以发起一个异步调用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时，get() 方法就自动返回了。主线程和异步线程之间的协作，Future 工具类已经帮我们解决了。除此之外，Java SDK 里提供的 CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是用来解决线程协作问题的。</p>
<h3 id="3-互斥"><a href="#3-互斥" class="headerlink" title="3. 互斥"></a>3. 互斥</h3><p>为了解决线程安全的<strong>可见性</strong>、<strong>有序性</strong>和<strong>原子性</strong>问题，Java 语言引入了内存模型，来解决可见性和有序性问题，但解决线程安全问题的核心方案还是互斥。</p>
<p><strong>互斥指同一时刻，只允许一个线程访问共享变量。</strong></p>
<p>实现互斥的核心技术就是锁，Java中锁的两套体系：synchronized和基于AQS实现的各种Lock。</p>
<p>除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读： Thread Local 和 final 关键字，Copy-on-write 的模式。</p>
<h1 id="可见性、原子性和有序性问题"><a href="#可见性、原子性和有序性问题" class="headerlink" title="可见性、原子性和有序性问题"></a>可见性、原子性和有序性问题</h1><p>矛盾：CPU与内存和I/O 设备的速度差异</p>
<p>==&gt; 解决方案：</p>
<ol>
<li>CPU与内存：CPU 增加了缓存，以均衡与内存的速度差异；</li>
<li>CPU与I/O 设备：操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li>
</ol>
<h2 id="缓存-gt-可见性问题"><a href="#缓存-gt-可见性问题" class="headerlink" title="缓存 ==&gt; 可见性问题"></a>缓存 ==&gt; 可见性问题</h2><p><strong>可见性</strong>指一个线程对共享变量的修改，另外一个线程能够立刻看到。</p>
<p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了。</p>
<h2 id="线程切换-gt-原子性问题"><a href="#线程切换-gt-原子性问题" class="headerlink" title="线程切换 ==&gt; 原子性问题"></a>线程切换 ==&gt; 原子性问题</h2><p>早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p>
<p><strong>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性</strong>。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符。</p>
<h2 id="编译优化-gt-有序性问题"><a href="#编译优化-gt-有序性问题" class="headerlink" title="编译优化 ==&gt; 有序性问题"></a>编译优化 ==&gt; 有序性问题</h2><p>有序性指的是程序按照代码的先后顺序执行。</p>
<p>编译器为了优化性能，有时候会改变程序中语句的先后顺序。</p>
<p>有时候编译器及解释器的优化可能导致意想不到的 Bug。</p>
<h1 id="Java内存模型：看Java如何解决可见性和有序性问题"><a href="#Java内存模型：看Java如何解决可见性和有序性问题" class="headerlink" title="Java内存模型：看Java如何解决可见性和有序性问题"></a>Java内存模型：看Java如何解决可见性和有序性问题</h1><p>导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>，但是这样问题虽然解决了，我们程序的性能可就堪忧了。</p>
<p>合理的方案应该是<strong>按需禁用</strong>缓存以及编译优化。</p>
<p>本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final</strong> 三个关键字，以及六项 <strong>Happens-Before 规则</strong>。</p>
<h2 id="使用-volatile-的困惑"><a href="#使用-volatile-的困惑" class="headerlink" title="使用 volatile 的困惑"></a>使用 volatile 的困惑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 在A线程执行writer()后，B线程执行reader()的 x 会是多少呢？</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK1.5之前，x 可能是 42，也有可能是 0；如果在 1.5 以上的版本上运行，x 就是等于 42。</p>
<blockquote>
<p>在JDK1.5之前，volatile只保证声明为volatile关键字的变量，但是不会管其他变量。且不保证代码顺序。</p>
</blockquote>
<h2 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h2><p><strong>前面一个操作的结果对后续操作是可见的</strong></p>
<p>Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。</p>
<ol>
<li><p>程序的顺序性规则：程序前面对某个变量的修改一定是对后续操作可见的。</p>
</li>
<li><p>volatile 变量规则：对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。</p>
</li>
<li><p>传递性规则：如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</p>
</li>
<li><p>管程中锁的规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。<strong>管程</strong>是一种通用的同步原语，在 Java 中是隐式实现的，指的就是 synchronized，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p>
</li>
</ol>
<blockquote>
<p>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。</p>
<p>管程是为了解决信号量在临界区的PV操作上的配对的麻烦，把配对的PV操作集中在一起，生成的一种并发编程方法。其中使用了条件变量这种同步机制。</p>
<p>管程由一个锁和0或多个条件变量组成。</p>
</blockquote>
<ol start="5">
<li><p>线程启动规则：主线程 A 启动子线程 B 后，子线程 B 能够看到主线程A在启动子线程 B 前的操作。</p>
</li>
<li><p>线程终止规则：主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对<strong>共享变量</strong>的操作。</p>
</li>
<li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</p>
</li>
<li><p>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</p>
</li>
</ol>
<h2 id="被我们忽视的-final"><a href="#被我们忽视的-final" class="headerlink" title="被我们忽视的 final"></a>被我们忽视的 final</h2><p>volatile 为的是禁用缓存以及编译优化，<strong>final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。</strong></p>
<p>Java 编译器在 1.5 以前的版本错误重排导致线程可能看到 final 变量的值会变化。</p>
<p>在 1.5 以后 Java 内存模型对 final 类型变量的重排进行了约束。现在只要我们提供正确构造函数没有“逸出”，就不会出问题了。</p>
<h1 id="互斥锁（上）：解决原子性问题"><a href="#互斥锁（上）：解决原子性问题" class="headerlink" title="互斥锁（上）：解决原子性问题"></a>互斥锁（上）：解决原子性问题</h1><p>原子性问题的源头是<strong>线程切换</strong></p>
<p>如果能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。</p>
<h2 id="简易锁模型"><a href="#简易锁模型" class="headerlink" title="简易锁模型"></a>简易锁模型</h2><p>把一段需要互斥执行的代码称为<strong>临界区</strong>。线程在进入临界区之前，首先尝试加锁 lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；否则呢就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁 unlock()。</p>
<h2 id="改进后的锁模型"><a href="#改进后的锁模型" class="headerlink" title="改进后的锁模型"></a>改进后的锁模型</h2><p>首先，把临界区要保护的资源标注出来，在临界区里增加了一个元素：受保护的资源 R；其次，为保护资源 R 创建一把锁 LR；最后，针对这把锁 LR，还需在进出临界区时添上加锁操作和解锁操作。</p>
<p><del>锁自家门来保护他家资产</del></p>
<h2 id="Java-语言提供的锁技术：synchronized"><a href="#Java-语言提供的锁技术：synchronized" class="headerlink" title="Java 语言提供的锁技术：synchronized"></a>Java 语言提供的锁技术：synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰代码块</span></span><br><span class="line">  Object obj = <span class="keyword">new</span> Object()；</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()，这样做的好处就是加锁 lock() 和解锁 unlock() 一定是成对出现的</p>
<blockquote>
<p>当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就是 Class X；<br>当修饰非静态方法的时候，锁定的是当前实例对象 this。</p>
</blockquote>
<h2 id="锁和受保护资源的关系"><a href="#锁和受保护资源的关系" class="headerlink" title="锁和受保护资源的关系"></a>锁和受保护资源的关系</h2><p><strong>受保护资源和锁之间的关联关系是 N:1 的关系</strong>。</p>
<h1 id="互斥锁（下）：如何用一把锁保护多个资源？"><a href="#互斥锁（下）：如何用一把锁保护多个资源？" class="headerlink" title="互斥锁（下）：如何用一把锁保护多个资源？"></a>互斥锁（下）：如何用一把锁保护多个资源？</h1><p>当我们要保护多个资源时，首先要区分这些资源是否存在关联关系。</p>
<h2 id="保护没有关联关系的多个资源"><a href="#保护没有关联关系的多个资源" class="headerlink" title="保护没有关联关系的多个资源"></a>保护没有关联关系的多个资源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 锁：保护账户余额</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object balLock</span><br><span class="line">    = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="comment">// 账户余额  </span></span><br><span class="line">  <span class="keyword">private</span> Integer balance;</span><br><span class="line">  <span class="comment">// 锁：保护账户密码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object pwLock</span><br><span class="line">    = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="comment">// 账户密码</span></span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 取款</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 查看余额</span></span><br><span class="line">  <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 更改密码</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">updatePassword</span><span class="params">(String pw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="keyword">this</span>.password = pw;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 查看密码</span></span><br><span class="line">  <span class="function">String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用同一把锁的问题：性能差，会导致操作都是串行执行。<strong>用不同的锁对受保护资源进行精细化管理，能够提升性能</strong>。这种锁还有个名字，叫<strong>细粒度锁</strong>。</p>
<h2 id="保护有关联关系的多个资源"><a href="#保护有关联关系的多个资源" class="headerlink" title="保护有关联关系的多个资源"></a>保护有关联关系的多个资源</h2><p>如果多个资源是有关联关系的，那这个问题就有点复杂了。例如银行业务里面的转账操作，账户 A 减少 100 元，账户 B 增加 100 元。这两个账户就是有关联关系的。那对于像转账这种有关联关系的操作，我们应该怎么去解决呢？先把这个问题代码化。我们声明了个账户类：Account，该类有一个成员变量余额：balance，还有一个用于转账的方法：transfer()，然后怎么保证转账操作 transfer() 没有并发问题呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信你的直觉会告诉你这样的解决方案：用户 synchronized 关键字修饰一下 transfer() 方法就可以了，于是你很快就完成了相关的代码，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，临界区内有两个资源，分别是转出账户的余额 this.balance 和转入账户的余额 target.balance，并且用的是一把锁 this，符合我们前面提到的，多个资源可以用一把锁来保护，这看上去完全正确呀。真的是这样吗？可惜，这个方案仅仅是看似正确，为什么呢？</p>
<p>问题就出在 this 这把锁上，<strong>this 这把锁可以保护自己的余额 this.balance，却保护不了别人的余额 target.balance</strong>，就像你不能用自家的锁来保护别人家的资产，也不能用自己的票来保护别人的座位一样。</p>
<h2 id="使用锁的正确姿势"><a href="#使用锁的正确姿势" class="headerlink" title="使用锁的正确姿势"></a>使用锁的正确姿势</h2><p><strong>锁能覆盖所有受保护资源</strong></p>
<p>对于保护同一类的不同实例，可以<strong>用XXX.class 作为共享的锁</strong>。Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><strong>使用细粒度锁可以提高并行度，是性能优化的一个重要手段</strong>。<strong>使用细粒度锁是有代价的，这个代价就是可能会导致死锁。</strong></p>
<p><strong>死锁</strong>的一个比较专业的定义是：<strong>一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象</strong>。</p>
<p>并发程序一旦死锁，一般没有特别好的方法，很多时候我们只能重启应用。因此，解决死锁问题最好的办法还是规避死锁。</p>
<p><strong>发生死锁的四个必要条件，只有以下这四个条件都发生时才会出现死锁：</strong></p>
<ul>
<li><strong>互斥条件：</strong>资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。</li>
<li><strong>不可剥夺条件：</strong>进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。</li>
<li><strong>请求和保持条件：</strong>进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。</li>
<li><strong>循环等待条件：</strong>在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。</li>
</ul>
<p>由于资源互斥是资源使用的固有特性是无法改变的，因此破坏死锁的情况如下：</p>
<ol>
<li><strong>破坏“不可剥夺”条件：</strong>一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。</li>
<li><strong>破坏”请求与保持条件“：</strong><ol>
<li>第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。</li>
<li>第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。</li>
</ol>
</li>
<li><strong>破坏“循环等待”条件：</strong>采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</li>
</ol>
<h1 id="用“等待-通知”机制优化循环等待"><a href="#用“等待-通知”机制优化循环等待" class="headerlink" title="用“等待-通知”机制优化循环等待"></a>用“等待-通知”机制优化循环等待</h1><p>在<strong>破坏占用且等待条件</strong>的时候，如果转出账本和转入账本不满足同时在文件架上这个条件，就用死循环的方式来循环等待，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line"><span class="keyword">while</span>(!actr.apply(<span class="keyword">this</span>, target))；</span><br></pre></td></tr></table></figure>

<p>如果 apply() 操作耗时长，或者并发冲突量大的时候，循环等待这种方案就不适用了，因为在这种场景下，可能要循环上万次才能获取到锁，太消耗 CPU 了。</p>
<p>在这种场景下，最好的方案应该是：如果线程要求的条件（转出账本和转入账本同在文件架上）不满足，则线程阻塞自己，进入<strong>等待</strong>状态；当线程要求的条件（转出账本和转入账本同在文件架上）满足后，<strong>通知</strong>等待的线程重新执行。</p>
<p><strong>一个完整的等待 - 通知机制：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁</strong>。</p>
<h2 id="用-synchronized-实现等待-通知机制"><a href="#用-synchronized-实现等待-通知机制" class="headerlink" title="用 synchronized 实现等待 - 通知机制"></a>用 synchronized 实现等待 - 通知机制</h2><p>synchronized 配合 wait()、notify()、notifyAll() </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(...)&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">        obj.wait(); <span class="comment">// 执行后进入等待队列</span></span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(...)&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">        obj.notify()/boj.notifyAll(); <span class="comment">// 从等待队列唤醒</span></span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：为防止虚假唤醒现象，要使用while而不是if作为判断条件。</p>
<h2 id="尽量使用-notifyAll"><a href="#尽量使用-notifyAll" class="headerlink" title="尽量使用 notifyAll()"></a>尽量使用 notifyAll()</h2><p><strong>notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等待队列中的所有线程</strong>。notify() 也很有风险，它的风险在于可能导致某些线程永远不会被通知到。</p>
<h1 id="安全性、活跃性以及性能问题"><a href="#安全性、活跃性以及性能问题" class="headerlink" title="安全性、活跃性以及性能问题"></a>安全性、活跃性以及性能问题</h1><h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><p>线程安全：其实本质上就是正确性，而正确性的含义就是<strong>程序按照我们期望的执行</strong>。</p>
<p>如何才能写出线程安全的程序呢？<strong>存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据时</strong>，要避免出现原子性问题、可见性问题和有序性问题。</p>
<p>解决共享数据的安全性方法：1）通过不共享数据或使数据状态不发生变化，如本地存储（Thread Local Storage，TLS）、不变模式；2）对于存在<strong>数据竞争</strong>的程序，通过锁实现。</p>
<p><strong>竞态条件，指的是程序的执行结果依赖线程执行的顺序</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (状态变量 满足 执行条件) &#123;  执行操作&#125;</span><br></pre></td></tr></table></figure>

<p>那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用<strong>互斥</strong>这个技术方案。从逻辑上来看，我们可以统一归为：<strong>锁</strong>。</p>
<h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><p>常见的活跃性问题，<strong>死锁</strong>、<strong>“活锁”</strong>和<strong>“饥饿”</strong>。</p>
<p>发生“死锁”后线程会互相等待，而且会一直等待下去，在技术上的表现形式是线程永久地“阻塞”了。</p>
<p>但<strong>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”</strong>。线程间可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。解决“<strong>活锁</strong>”的方案很简单，谦让时，<strong>尝试等待一个随机的时间</strong>就可以了。</p>
<p><strong>“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况</strong>。如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。解决“<strong>饥饿</strong>”问题的方案很简单，有三种方案：<strong>一是保证资源充足</strong>，<strong>二是公平地分配资源</strong>，<strong>三就是避免持有锁的线程长时间执行</strong>。</p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了</p>
<p>阿姆达尔（Amdahl）定律，代表了处理器并行运算之后效率提升的能力<br>$$<br>s = \frac{1}{(1-p) + \frac{p}{n}}<br>$$<br>公式里的 S 为加速比， n 可以理解为 CPU 的核数，p 可以理解为并行百分比，那（1-p）就是串行百分比</p>
<blockquote>
<p>临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比</p>
</blockquote>
<p><strong>避免锁带来的性能问题？</strong></p>
<p>第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。</p>
<p>第二，减少锁持有的时间。使用细粒度的锁，使用读写锁</p>
<p><strong>性能指标</strong></p>
<p>三个指标非常重要，就是：<strong>吞吐量</strong>、<strong>延迟</strong>和<strong>并发量</strong>。</p>
<ol>
<li>吞吐量：指的是<strong>单位时间内能处理的请求数量</strong>。吞吐量越高，说明性能越好。</li>
<li>延迟：指的是<strong>从发出请求到收到响应的时间</strong>。延迟越小，说明性能越好。</li>
<li>并发量：指的是<strong>能同时处理的请求数量</strong>，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。</li>
</ol>
<h1 id="管程：并发编程的万能钥匙"><a href="#管程：并发编程的万能钥匙" class="headerlink" title="管程：并发编程的万能钥匙"></a>管程：并发编程的万能钥匙</h1><h2 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h2><p>管程，对应的英文是 Monitor，很多 Java 领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这个是意译，而我自己也更倾向于使用“管程”。</p>
<p>所谓<strong>管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发</strong>。</p>
<h2 id="MESA-模型"><a href="#MESA-模型" class="headerlink" title="MESA 模型"></a>MESA 模型</h2><p>在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen 模型、Hoare 模型和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。</p>
<p><strong>管程是如何解决互斥问题的</strong>：</p>
<p>管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。</p>
<p>管程 X 将共享变量 queue 这个队列和相关的操作入队 enq()、出队 deq() 都封装起来了；线程 A 和线程 B 如果想访问共享变量 queue，只能通过调用管程提供的 enq()、deq() 方法来实现；enq()、deq() 保证互斥性，只允许一个线程进入管程。</p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211108210517043.png" alt="image-20211108210517043" style="zoom:50%;" />

<p><strong>管程如何解决线程间的同步问题</strong></p>
<p>在管程模型里，共享变量和对共享变量的操作是被封装起来的，图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。管程里还引入了条件变量的概念，而且<strong>每个条件变量都对应有一个等待队列</strong>，如下图，条件变量 A 和条件变量 B 分别都有自己的等待队列。<strong>条件变量和等待队列用来解决线程同步问题。</strong></p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211108210706017.png" alt="image-20211108210706017" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// 条件变量：队列不满    final Condition notFull = lock.newCondition();  // 条件变量：队列不空    final Condition notEmpty = lock.newCondition();  ...// 创建队列的数据结构   // 入队  void enq(T x) &#123;    lock.lock();    try &#123;      while (队列已满)&#123;        // 进入“队列不满”条件的等待队列中，等待“队列不满”的条件唤醒        notFull.await();      &#125;        // 省略入队操作...      // 入队后, “队列不空”的条件唤醒         notEmpty.signal();    &#125;finally &#123;      lock.unlock();    &#125;  &#125;      // 出队  void deq()&#123;    lock.lock();    try &#123;      while (队列已空)&#123;        // 进入“队列不空”条件的等待队列中，等待“队列不空”的条件唤醒        notEmpty.await();      &#125;      // 省略出队操作...      // 出队后，“队列不满”的条件唤醒      notFull.signal();    &#125;finally &#123;      lock.unlock();    &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="wait-的正确姿势"><a href="#wait-的正确姿势" class="headerlink" title="wait() 的正确姿势"></a>wait() 的正确姿势</h2><p>对于 MESA 管程来说，有一个编程范式，就是需要在一个 while 循环里面调用 wait()。<strong>这个是 MESA 管程特有的</strong>。</p>
<p>Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别就是当条件满足后，如何通知相关线程。</p>
<blockquote>
<p>管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行呢？</p>
<ol>
<li>Hasen 模型里面，要求 notify() 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。</li>
<li>Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤醒操作。</li>
<li>MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。</li>
</ol>
</blockquote>
<h2 id="notify-何时可以使用"><a href="#notify-何时可以使用" class="headerlink" title="notify() 何时可以使用"></a>notify() 何时可以使用</h2><p>**除非经过深思熟虑，否则尽量使用 notifyAll()**。那什么时候可以使用 notify() 呢？需要满足以下三个条件：</p>
<ol>
<li>所有等待线程拥有相同的等待条件；</li>
<li>所有等待线程被唤醒后，执行相同的操作；</li>
<li>只需要唤醒一个线程。</li>
</ol>
<h1 id="Java线程（上）：Java线程的生命周期"><a href="#Java线程（上）：Java线程的生命周期" class="headerlink" title="Java线程（上）：Java线程的生命周期"></a>Java线程（上）：Java线程的生命周期</h1><p>Java 语言里的线程本质上就是操作系统的线程，它们是一一对应的。</p>
<h2 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="headerlink" title="通用的线程生命周期"></a>通用的线程生命周期</h2><p>通用的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：<strong>初始状态、可运行状态、运行状态、休眠状态</strong>和<strong>终止状态</strong>。</p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211108213443197.png" alt="image-20211108213443197" style="zoom:50%;" />

<ol>
<li><strong>初始状态</strong>，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。</li>
<li><strong>可运行状态</strong>，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。</li>
<li>当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成了<strong>运行状态</strong>。</li>
<li>运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到<strong>休眠状态</strong>，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</li>
<li>线程执行完或者出现异常就会进入<strong>终止状态</strong>，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。</li>
</ol>
<h2 id="Java-中线程的生命周期"><a href="#Java-中线程的生命周期" class="headerlink" title="Java 中线程的生命周期"></a>Java 中线程的生命周期</h2><p>Java 语言中线程共有六种状态，分别是：</p>
<ol>
<li>NEW（初始化状态）</li>
<li>RUNNABLE（可运行 / 运行状态）</li>
<li>BLOCKED（阻塞状态）</li>
<li>WAITING（无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）</li>
</ol>
<p>在操作系统层面，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的<strong>休眠状态</strong>。也就是说<strong>只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权</strong>。</p>
<p><img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/201410311002063.png" alt="img"></p>
<h3 id="1-RUNNABLE-与-BLOCKED-的状态转换"><a href="#1-RUNNABLE-与-BLOCKED-的状态转换" class="headerlink" title="1. RUNNABLE 与 BLOCKED 的状态转换"></a>1. RUNNABLE 与 BLOCKED 的状态转换</h3><p>只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁。</p>
<p>synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。</p>
<h3 id="2-RUNNABLE-与-WAITING-的状态转换"><a href="#2-RUNNABLE-与-WAITING-的状态转换" class="headerlink" title="2. RUNNABLE 与 WAITING 的状态转换"></a>2. RUNNABLE 与 WAITING 的状态转换</h3><p>第一种场景，获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法。</p>
<p>第二种场景，调用无参数的 Thread.join() 方法。</p>
<blockquote>
<p>例如有一个线程对象 thread A，当调用 A.join() 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。</p>
</blockquote>
<p>第三种场景，调用 LockSupport.park() 方法。</p>
<h3 id="3-RUNNABLE-与-TIMED-WAITING-的状态转换"><a href="#3-RUNNABLE-与-TIMED-WAITING-的状态转换" class="headerlink" title="3. RUNNABLE 与 TIMED_WAITING 的状态转换"></a>3. RUNNABLE 与 TIMED_WAITING 的状态转换</h3><p>有五种场景会触发这种转换：</p>
<ol>
<li>调用<strong>带超时参数</strong>的 Thread.sleep(long millis) 方法；</li>
<li>获得 synchronized 隐式锁的线程，调用<strong>带超时参数</strong>的 Object.wait(long timeout) 方法；</li>
<li>调用<strong>带超时参数</strong>的 Thread.join(long millis) 方法；</li>
<li>调用<strong>带超时参数</strong>的 LockSupport.parkNanos(Object blocker, long deadline) 方法；</li>
<li>调用<strong>带超时参数</strong>的 LockSupport.parkUntil(long deadline) 方法。</li>
</ol>
<h3 id="4-从-NEW-到-RUNNABLE-状态"><a href="#4-从-NEW-到-RUNNABLE-状态" class="headerlink" title="4. 从 NEW 到 RUNNABLE 状态"></a>4. 从 NEW 到 RUNNABLE 状态</h3><p>从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start() 方法就可以了</p>
<h3 id="5-从-RUNNABLE-到-TERMINATED-状态"><a href="#5-从-RUNNABLE-到-TERMINATED-状态" class="headerlink" title="5. 从 RUNNABLE 到 TERMINATED 状态"></a>5. 从 RUNNABLE 到 TERMINATED 状态</h3><p>线程执行完 run() 方法后，会自动转换到 TERMINATED 状态；</p>
<p>当然如果执行 run() 方法的时候异常抛出，也会导致线程终止；</p>
<p>调用stop() 或 interrupt() 方法</p>
<p><strong>那 stop() 和 interrupt() 方法的主要区别是什么呢？</strong></p>
<p>stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被 stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁。</p>
<p>interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。</p>
<blockquote>
<p>被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。</p>
<p>1）异常</p>
<p>当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。</p>
<p>当线程 A 处于 RUNNABLE 状态时，并且阻塞在 java.nio.channels.InterruptibleChannel 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 会触发 java.nio.channels.ClosedByInterruptException 这个异常；而阻塞在 java.nio.channels.Selector 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 的 java.nio.channels.Selector 会立即返回。</p>
<blockquote>
<p>当抛出异常并被try-catch捕捉到后，中断标志会被清除掉，因此如下代码会死循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread th = Thread.currentThread();<span class="keyword">while</span>(<span class="keyword">true</span>) &#123; <span class="keyword">if</span>(th.isInterrupted()) &#123;		<span class="keyword">break</span>; &#125; <span class="comment">// 省略业务代码无数 try &#123;		Thread.sleep(100); &#125;catch (InterruptedException e)&#123;		e.printStackTrace();     // 正确方式：重新设置中断标志位		// th.interrupt(); &#125;&#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>2）主动检测</p>
<p>如果其他线程调用线程 A 的 interrupt() 方法，那么线程 A 可以通过 isInterrupted() 方法，检测是不是自己被中断了。</p>
</blockquote>
<p>你可以通过 <code>jstack</code> 命令或者<code>Java VisualVM</code>这个可视化工具将 JVM 所有的线程栈信息导出来，完整的线程栈信息不仅包括线程的当前状态、调用栈，还包括了锁的信息。</p>
<h1 id="Java线程（中）：创建多少线程才是合适的？"><a href="#Java线程（中）：创建多少线程才是合适的？" class="headerlink" title="Java线程（中）：创建多少线程才是合适的？"></a>Java线程（中）：创建多少线程才是合适的？</h1><ol>
<li><p>为什么要使用多线程？</p>
</li>
<li><p>多线程的应用场景有哪些？</p>
</li>
</ol>
<h2 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h2><p>使用多线程，本质上就是提升程序性能。所谓提升性能，从度量的角度，主要是<strong>降低延迟，提高吞吐量</strong>。</p>
<h2 id="多线程的应用场景"><a href="#多线程的应用场景" class="headerlink" title="多线程的应用场景"></a>多线程的应用场景</h2><p><strong>在并发编程领域，提升性能本质上就是提升硬件的利用率，再具体点来说，就是提升 I/O 的利用率和 CPU 的利用率</strong>。</p>
<p><strong>我们需要解决 CPU 和 I/O 设备综合利用率的问题</strong>。==&gt; <strong>使用多线程</strong></p>
<p><strong>如果 CPU 和 I/O 设备的利用率都很低，那么可以尝试通过增加线程来提高吞吐量</strong>。</p>
<h2 id="创建多少线程合适？"><a href="#创建多少线程合适？" class="headerlink" title="创建多少线程合适？"></a>创建多少线程合适？</h2><p>对于 CPU 密集型的计算场景，<strong>理论上“线程的数量 =CPU 核数”就是最合适的</strong>。不过在工程上，<strong>线程的数量一般会设置为“CPU 核数 +1”</strong>。</p>
<p>对于 I/O 密集型的计算场景，最佳的线程数是与程序中 CPU 计算和 I/O 操作的耗时比相关的，我们可以总结出这样一个公式：<br>$$<br>最佳线程数 = CPU核数 * (1 +\frac{I/O 耗时}{CPU 耗时}）<br>$$</p>
<h1 id="Java线程（下）：为什么局部变量是线程安全的？"><a href="#Java线程（下）：为什么局部变量是线程安全的？" class="headerlink" title="Java线程（下）：为什么局部变量是线程安全的？"></a>Java线程（下）：为什么局部变量是线程安全的？</h1><h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><h1 id="如何用面向对象思想写好并发程序？"><a href="#如何用面向对象思想写好并发程序？" class="headerlink" title="如何用面向对象思想写好并发程序？"></a>如何用面向对象思想写好并发程序？</h1><h2 id="一、封装共享变量"><a href="#一、封装共享变量" class="headerlink" title="一、封装共享变量"></a>一、封装共享变量</h2><h2 id="二、识别共享变量间的约束条件"><a href="#二、识别共享变量间的约束条件" class="headerlink" title="二、识别共享变量间的约束条件"></a>二、识别共享变量间的约束条件</h2><h2 id="三、制定并发访问策略"><a href="#三、制定并发访问策略" class="headerlink" title="三、制定并发访问策略"></a>三、制定并发访问策略</h2><ol>
<li>优先使用成熟的工具类。</li>
<li>迫不得已时才使用低级的同步原语。</li>
<li>避免过早优化。</li>
</ol>
<h1 id="Lock和Condition（上）：隐藏在并发包中的管程"><a href="#Lock和Condition（上）：隐藏在并发包中的管程" class="headerlink" title="Lock和Condition（上）：隐藏在并发包中的管程"></a>Lock和Condition（上）：隐藏在并发包中的管程</h1><p><strong>Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题</strong>。</p>
<p>Java 语言本身提供的 synchronized 也是管程的一种实现，既然 Java 从语言层面已经实现了管程了，那为什么还要在 SDK 里提供另外一种实现呢？</p>
<h2 id="再造管程的理由"><a href="#再造管程的理由" class="headerlink" title="再造管程的理由"></a>再造管程的理由</h2><p>破坏<strong>不可剥夺条件</strong>方案：用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</p>
<ol>
<li><strong>能够响应中断</strong>。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。</li>
<li><strong>支持超时</strong>。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>
<li><strong>非阻塞地获取锁</strong>。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>
</ol>
<p>这三种方案可以全面弥补 synchronized 的问题。体现在 API 上，就是 Lock 接口的三个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持中断的 APIvoid lockInterruptibly() throws InterruptedException;// 支持超时的 APIboolean tryLock(long time, TimeUnit unit) throws InterruptedException;// 支持非阻塞获取锁的 APIboolean tryLock();</span></span><br></pre></td></tr></table></figure>

<h2 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h2><p><strong>Java SDK 里面 Lock 靠什么保证可见性呢？利用了 volatile 相关的 Happens-Before 规则</strong>。Java SDK 里面的 ReentrantLock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写 state 的值；解锁的时候，也会读写 state 的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;  <span class="keyword">private</span> <span class="keyword">final</span> Lock rtl = <span class="keyword">new</span> ReentrantLock();  <span class="keyword">int</span> value;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;    <span class="comment">// 获取锁    rtl.lock();      try &#123;      value+=1;    &#125; finally &#123;      // 保证锁能释放      rtl.unlock();    &#125;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 根据相关的 Happens-Before 规则：</p>
<ol>
<li><strong>顺序性规则</strong>：对于线程 T1，value+=1 Happens-Before 释放锁的操作 unlock()；</li>
<li><strong>volatile 变量规则</strong>：由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作；</li>
<li><strong>传递性规则</strong>：线程 T1 的 value+=1 Happens-Before 线程 T2 的 lock() 操作。</li>
</ol>
</blockquote>
<h2 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h2><p><strong>可重入锁，顾名思义，指的是线程可以重复获取同一把锁</strong>。</p>
<p><strong>可重入函数，指的是多个线程可以同时调用该函数</strong>，每个线程都能得到正确结果；同时在一个线程内支持线程切换，无论被切换多少次，结果都是正确的。</p>
<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>ReentrantLock 这个类有两个构造函数，一个是无参构造函数，一个是传入 fair 参数的构造函数。fair 参数代表的是锁的公平策略，如果传入 true 就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造函数：默认非公平锁public ReentrantLock() &#123;    sync = new NonfairSync();&#125;// 根据公平策略参数创建锁public ReentrantLock(boolean fair)&#123;    sync = fair ? new FairSync() : new NonfairSync();&#125;</span></span><br></pre></td></tr></table></figure>

<p>锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。</p>
<h2 id="用锁的最佳实践"><a href="#用锁的最佳实践" class="headerlink" title="用锁的最佳实践"></a>用锁的最佳实践</h2><p>Doug Lea《Java 并发编程：设计原则与模式》一书中，推荐的三个用锁的最佳实践，它们分别是：</p>
<blockquote>
<ol>
<li>永远只在更新对象的成员变量时加锁</li>
<li>永远只在访问可变的成员变量时加锁</li>
<li>永远不在调用其他对象的方法时加锁</li>
</ol>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/EdwardLee50/EdwardLee50.github.io/tags/java-%E5%B9%B6%E5%8F%91/" rel="tag"># java,并发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/EdwardLee50/EdwardLee50.github.io/2019/12/20/Java%E5%9F%BA%E7%A1%80/" rel="prev" title="Java 基础">
      <i class="fa fa-chevron-left"></i> Java 基础
    </a></div>
      <div class="post-nav-item">
    <a href="/EdwardLee50/EdwardLee50.github.io/2020/04/16/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="next" title="Java并发摘要笔记（二）">
      Java并发摘要笔记（二） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%86%E5%B7%A5"><span class="nav-number">1.1.</span> <span class="nav-text">1. 分工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%90%8C%E6%AD%A5-%E5%8D%8F%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">2. 同步&#x2F;协作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BA%92%E6%96%A5"><span class="nav-number">1.3.</span> <span class="nav-text">3. 互斥</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">可见性、原子性和有序性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98-gt-%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">缓存 &#x3D;&#x3D;&gt; 可见性问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2-gt-%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">线程切换 &#x3D;&#x3D;&gt; 原子性问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-gt-%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">编译优化 &#x3D;&#x3D;&gt; 有序性问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%9C%8BJava%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">Java内存模型：看Java如何解决可见性和有序性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-volatile-%E7%9A%84%E5%9B%B0%E6%83%91"><span class="nav-number">1.</span> <span class="nav-text">使用 volatile 的困惑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Happens-Before-%E8%A7%84%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">Happens-Before 规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A2%AB%E6%88%91%E4%BB%AC%E5%BF%BD%E8%A7%86%E7%9A%84-final"><span class="nav-number">3.</span> <span class="nav-text">被我们忽视的 final</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">互斥锁（上）：解决原子性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E6%98%93%E9%94%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">简易锁模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E9%94%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">改进后的锁模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E8%AF%AD%E8%A8%80%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81%E6%8A%80%E6%9C%AF%EF%BC%9Asynchronized"><span class="nav-number">3.</span> <span class="nav-text">Java 语言提供的锁技术：synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E5%92%8C%E5%8F%97%E4%BF%9D%E6%8A%A4%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.</span> <span class="nav-text">锁和受保护资源的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E6%8A%8A%E9%94%81%E4%BF%9D%E6%8A%A4%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">互斥锁（下）：如何用一把锁保护多个资源？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%B2%A1%E6%9C%89%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90"><span class="nav-number">1.</span> <span class="nav-text">保护没有关联关系的多个资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%9C%89%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90"><span class="nav-number">2.</span> <span class="nav-text">保护有关联关系的多个资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF"><span class="nav-number">3.</span> <span class="nav-text">使用锁的正确姿势</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number"></span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E2%80%9C%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E2%80%9D%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="nav-number"></span> <span class="nav-text">用“等待-通知”机制优化循环等待</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8-synchronized-%E5%AE%9E%E7%8E%B0%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">用 synchronized 实现等待 - 通知机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8-notifyAll"><span class="nav-number">2.</span> <span class="nav-text">尽量使用 notifyAll()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%81%E6%B4%BB%E8%B7%83%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">安全性、活跃性以及性能问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">安全性问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">活跃性问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">性能问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%87%E8%83%BD%E9%92%A5%E5%8C%99"><span class="nav-number"></span> <span class="nav-text">管程：并发编程的万能钥匙</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%A1%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">什么是管程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MESA-%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">MESA 模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF"><span class="nav-number">3.</span> <span class="nav-text">wait() 的正确姿势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#notify-%E4%BD%95%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">notify() 何时可以使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number"></span> <span class="nav-text">Java线程（上）：Java线程的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.</span> <span class="nav-text">通用的线程生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.</span> <span class="nav-text">Java 中线程的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-RUNNABLE-%E4%B8%8E-BLOCKED-%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.1.</span> <span class="nav-text">1. RUNNABLE 与 BLOCKED 的状态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-RUNNABLE-%E4%B8%8E-WAITING-%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.</span> <span class="nav-text">2. RUNNABLE 与 WAITING 的状态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-RUNNABLE-%E4%B8%8E-TIMED-WAITING-%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">3. RUNNABLE 与 TIMED_WAITING 的状态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BB%8E-NEW-%E5%88%B0-RUNNABLE-%E7%8A%B6%E6%80%81"><span class="nav-number">2.4.</span> <span class="nav-text">4. 从 NEW 到 RUNNABLE 状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BB%8E-RUNNABLE-%E5%88%B0-TERMINATED-%E7%8A%B6%E6%80%81"><span class="nav-number">2.5.</span> <span class="nav-text">5. 从 RUNNABLE 到 TERMINATED 状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E6%89%8D%E6%98%AF%E5%90%88%E9%80%82%E7%9A%84%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">Java线程（中）：创建多少线程才是合适的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">为什么要使用多线程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">多线程的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">创建多少线程合适？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">Java线程（下）：为什么局部变量是线程安全的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD"><span class="nav-number">1.</span> <span class="nav-text">线程封闭</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E5%86%99%E5%A5%BD%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">如何用面向对象思想写好并发程序？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B0%81%E8%A3%85%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="nav-number">1.</span> <span class="nav-text">一、封装共享变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%AF%86%E5%88%AB%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E9%97%B4%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">二、识别共享变量间的约束条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%88%B6%E5%AE%9A%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%AD%96%E7%95%A5"><span class="nav-number">3.</span> <span class="nav-text">三、制定并发访问策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lock%E5%92%8CCondition%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E9%9A%90%E8%97%8F%E5%9C%A8%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">Lock和Condition（上）：隐藏在并发包中的管程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E9%80%A0%E7%AE%A1%E7%A8%8B%E7%9A%84%E7%90%86%E7%94%B1"><span class="nav-number">1.</span> <span class="nav-text">再造管程的理由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">如何保证可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">什么是可重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">公平锁与非公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E9%94%81%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.</span> <span class="nav-text">用锁的最佳实践</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EdwardLee50"
      src="/EdwardLee50/EdwardLee50.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">EdwardLee50</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/EdwardLee50/EdwardLee50.github.io/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/EdwardLee50/EdwardLee50.github.io/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/EdwardLee50/EdwardLee50.github.io/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:EdwardLee50@163.com" title="E-Mail → mailto:EdwardLee50@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EdwardLee50</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/EdwardLee50/EdwardLee50.github.io/lib/anime.min.js"></script>
  <script src="/EdwardLee50/EdwardLee50.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/EdwardLee50/EdwardLee50.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/EdwardLee50/EdwardLee50.github.io/js/utils.js"></script>

<script src="/EdwardLee50/EdwardLee50.github.io/js/motion.js"></script>


<script src="/EdwardLee50/EdwardLee50.github.io/js/schemes/pisces.js"></script>


<script src="/EdwardLee50/EdwardLee50.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
