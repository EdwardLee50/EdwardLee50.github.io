<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/EdwardLee50.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/EdwardLee50.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/EdwardLee50.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/EdwardLee50.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/EdwardLee50.github.io/css/main.css">


<link rel="stylesheet" href="/EdwardLee50.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"edwardlee50.github.io","root":"/EdwardLee50.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Lock和Condition（下）：Dubbo如何用管程实现异步转同步？Condition 实现了管程模型里面的条件变量，Java 语言内置的管程里只有一个条件变量，而 Lock&amp;Condition 实现的管程是支持多个条件变量的。 那如何利用两个条件变量快速实现阻塞队列呢？ 一个阻塞队列，需要两个条件变量，一个是队列不空（空队列不允许出队），另一个是队列不满（队列已满不允许入队）。 同步">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发摘要笔记（二）">
<meta property="og:url" content="https://edwardlee50.github.io/EdwardLee50.github.io/2020/04/16/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="EdwardLee50&#39;s Blog">
<meta property="og:description" content="Lock和Condition（下）：Dubbo如何用管程实现异步转同步？Condition 实现了管程模型里面的条件变量，Java 语言内置的管程里只有一个条件变量，而 Lock&amp;Condition 实现的管程是支持多个条件变量的。 那如何利用两个条件变量快速实现阻塞队列呢？ 一个阻塞队列，需要两个条件变量，一个是队列不空（空队列不允许出队），另一个是队列不满（队列已满不允许入队）。 同步">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109144846958.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109162351270.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109164605594.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109165401099.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109165439629.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211110231109824.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211110232839684.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211110233203501.png">
<meta property="og:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211110234033937.png">
<meta property="article:published_time" content="2020-04-16T02:06:34.083Z">
<meta property="article:modified_time" content="2020-04-17T07:13:54.854Z">
<meta property="article:author" content="EdwardLee50">
<meta property="article:tag" content="java,并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109144846958.png">

<link rel="canonical" href="https://edwardlee50.github.io/EdwardLee50.github.io/2020/04/16/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发摘要笔记（二） | EdwardLee50's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/EdwardLee50.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EdwardLee50's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/EdwardLee50.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/EdwardLee50.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/EdwardLee50.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/EdwardLee50.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://edwardlee50.github.io/EdwardLee50.github.io/2020/04/16/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/EdwardLee50.github.io/images/avatar.png">
      <meta itemprop="name" content="EdwardLee50">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EdwardLee50's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发摘要笔记（二）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">

              

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-16 10:06:34" itemprop="dateCreated datePublished" datetime="2020-04-16T10:06:34+08:00">2020-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-17 15:13:54" itemprop="dateModified" datetime="2020-04-17T15:13:54+08:00">2020-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/EdwardLee50.github.io/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/EdwardLee50.github.io/categories/java/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Lock和Condition（下）：Dubbo如何用管程实现异步转同步？"><a href="#Lock和Condition（下）：Dubbo如何用管程实现异步转同步？" class="headerlink" title="Lock和Condition（下）：Dubbo如何用管程实现异步转同步？"></a>Lock和Condition（下）：Dubbo如何用管程实现异步转同步？</h1><p><strong>Condition 实现了管程模型里面的条件变量</strong>，Java 语言内置的管程里只有一个条件变量，而 Lock&amp;Condition 实现的管程是支持多个条件变量的。</p>
<p><strong>那如何利用两个条件变量快速实现阻塞队列呢？</strong></p>
<p>一个阻塞队列，需要两个条件变量，一个是队列不空（空队列不允许出队），另一个是队列不满（队列已满不允许入队）。</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步和异步的区别到底是什么呢？<strong>通俗点来讲就是调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步</strong>。</p>
<p>同步，是 Java 代码默认的处理方式。如果你想让你的程序支持异步，可以通过下面两种方式来实现：</p>
<ol>
<li>调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用；</li>
<li>方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接 return，这种方法我们一般称为异步方法。</li>
</ol>
<span id="more"></span>
<h2 id="Dubbo-源码分析"><a href="#Dubbo-源码分析" class="headerlink" title="Dubbo 源码分析"></a>Dubbo 源码分析</h2><p> TCP 协议本身就是异步的，我们工作中经常用到的 RPC 调用，<strong>在 TCP 协议层面，发送完 RPC 请求后，线程是不会等待 RPC 的响应结果的</strong>。</p>
<p>Dubbo 异步转同步的功能应该是通过 DefaultFuture 这个类实现的。</p>
<p>我们的需求：当 RPC 返回结果之前，阻塞调用线程，让调用线程等待；当 RPC 返回结果后，唤醒调用线程，让调用线程重新执行。</p>
<blockquote>
<p>经典的等待 - 通知机制</p>
</blockquote>
<p>Dubbo 的实现（精简版）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁与条件变量private final Lock lock = new ReentrantLock();private final Condition done = lock.newCondition(); // 调用方通过该方法等待结果Object get(int timeout)&#123;  long start = System.nanoTime();  lock.lock();  try &#123;	while (!isDone()) &#123;	  done.await(timeout); // 阻塞等待结果返回      long cur=System.nanoTime();	  if (isDone() ||           cur-start &gt; timeout)&#123;	    break;	  &#125;	&#125;  &#125; finally &#123;	lock.unlock();  &#125;  if (!isDone()) &#123;	throw new TimeoutException();  &#125;  return returnFromResponse();&#125;// RPC 结果是否已经返回boolean isDone() &#123;  return response != null;&#125;// RPC 结果返回时调用该方法   private void doReceived(Response res) &#123;  lock.lock();  try &#123;    response = res;    if (done != null) &#123;      done.signalAll();    &#125;  &#125; finally &#123;    lock.unlock();  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用线程通过调用 get() 方法等待 RPC 返回结果，这个方法里面，你看到的都是熟悉的“面孔”：调用 lock() 获取锁，在 finally 里面调用 unlock() 释放锁；获取锁后，通过经典的在循环中调用 await() 方法来实现等待。</p>
<p>当 RPC 结果返回时，会调用 doReceived() 方法，这个方法里面，调用 lock() 获取锁，在 finally 里面调用 unlock() 释放锁，获取锁后通过调用 signal() 来通知调用线程，结果已经返回，不用继续等待了。</p>
<h1 id="Semaphore：如何快速实现一个限流器？"><a href="#Semaphore：如何快速实现一个限流器？" class="headerlink" title="Semaphore：如何快速实现一个限流器？"></a>Semaphore：如何快速实现一个限流器？</h1><h2 id="信号量模型"><a href="#信号量模型" class="headerlink" title="信号量模型"></a>信号量模型</h2><p>信号量模型还是很简单的，可以简单概括为：<strong>一个计数器，一个等待队列，三个方法</strong>。</p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109144846958.png" alt="image-20211109144846958" style="zoom:50%;" />

<p>在信号量模型里，计数器和等待队列对外是透明的，所以只能通过信号量模型提供的三个方法来访问它们，这三个方法分别是：init()、down() 和 up()。</p>
<ul>
<li>init()：设置计数器的初始值。</li>
<li>down()：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。</li>
<li>up()：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。</li>
</ul>
<p>nit()、down() 和 up() 三个方法都是原子性的，并且这个原子性是由信号量模型的实现方保证的。在 Java SDK 里面，信号量模型是由 java.util.concurrent.Semaphore 实现的，Semaphore 这个类能够保证这三个方法都是原子操作。</p>
<p>信号量模型里面，down()、up() 这两个操作历史上最早称为 P 操作和 V 操作，所以信号量模型也被称为 PV 原语。在 Java SDK 并发包里，down() 和 up() 对应的则是 acquire() 和 release()。</p>
<h2 id="如何使用信号量"><a href="#如何使用信号量" class="headerlink" title="如何使用信号量"></a>如何使用信号量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;<span class="comment">// 初始化信号量static final Semaphore s     = new Semaphore(1);// 用信号量保证互斥    static void addOne() &#123;  s.acquire();  try &#123;    count+=1;  &#125; finally &#123;    s.release();  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="快速实现一个限流器"><a href="#快速实现一个限流器" class="headerlink" title="快速实现一个限流器"></a>快速实现一个限流器</h2><p><strong>Semaphore 可以允许多个线程访问一个临界区</strong>。比较常见的需求就是我们工作中遇到的各种池化资源。</p>
<p>对象池的示例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjPool</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;  <span class="keyword">final</span> List&lt;T&gt; pool;  <span class="comment">// 用信号量实现限流器  final Semaphore sem;  // 构造函数  ObjPool(int size, T t)&#123;    pool = new Vector&lt;T&gt;()&#123;&#125;;    for(int i=0; i&lt;size; i++)&#123;      pool.add(t);    &#125;    sem = new Semaphore(size);  &#125;  // 利用对象池的对象，调用 func  R exec(Function&lt;T,R&gt; func) &#123;    T t = null;    sem.acquire();    try &#123;      t = pool.remove(0);      return func.apply(t);    &#125; finally &#123;      pool.add(t);      sem.release();    &#125;  &#125;&#125;// 创建对象池ObjPool&lt;Long, String&gt; pool = new ObjPool&lt;Long, String&gt;(10, 2);// 通过对象池获取 t，之后执行  pool.exec(t -&gt; &#123;    System.out.println(t);    return t.toString();&#125;);</span></span><br></pre></td></tr></table></figure>

<h1 id="ReadWriteLock：如何快速实现一个完备的缓存？"><a href="#ReadWriteLock：如何快速实现一个完备的缓存？" class="headerlink" title="ReadWriteLock：如何快速实现一个完备的缓存？"></a>ReadWriteLock：如何快速实现一个完备的缓存？</h1><p>实际工作中，为了优化性能，我们经常会使用缓存，例如缓存元数据、缓存基础数据等，这就是一种典型的读多写少应用场景。缓存之所以能提升性能，一个重要的条件就是缓存的数据一定是读多写少的。</p>
<p><strong>那什么是读写锁呢？</strong></p>
<p>所有的读写锁都遵守以下三条基本原则：</p>
<ol>
<li>允许多个线程同时读共享变量；</li>
<li>只允许一个线程写共享变量；</li>
<li>如果一个写线程正在执行写操作，此时禁止读线程读共享变量。</li>
</ol>
<p>读写锁与互斥锁的一个重要区别就是<strong>读写锁允许多个线程同时读共享变量</strong>，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但<strong>读写锁的写操作是互斥的</strong>，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。</p>
<h2 id="快速实现一个缓存"><a href="#快速实现一个缓存" class="headerlink" title="快速实现一个缓存"></a>快速实现一个缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="keyword">final</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();  <span class="comment">// 读锁  final Lock r = rwl.readLock();  // 写锁  final Lock w = rwl.writeLock();  // 读缓存  V get(K key) &#123;    r.lock();    try &#123; return m.get(key); &#125;    finally &#123; r.unlock(); &#125;  &#125;  // 写缓存  V put(String key, Data v) &#123;    w.lock();    try &#123; return m.put(key, v); &#125;    finally &#123; w.unlock(); &#125;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>缓存的数据保存在 Cache 类内部的 HashMap 里面，HashMap 不是线程安全的，这里我们使用读写锁 ReadWriteLock 来保证其线程安全。ReadWriteLock 是一个接口，它的实现类是 ReentrantReadWriteLock。</p>
<p>Cache 这个工具类，我们提供了两个方法，一个是读缓存方法 get()，另一个是写缓存方法 put()。读缓存需要用到读锁，读锁的使用和前面我们介绍的 Lock 的使用是相同的，都是 try{}finally{}这个编程范式。写缓存则需要用到写锁，写锁的使用和读锁是类似的。这样看来，读写锁的使用还是非常简单的。</p>
<p><strong>使用缓存首先要解决缓存数据的初始化问题</strong>。</p>
<p>缓存数据的初始化，可以采用一次性加载的方式，也可以使用按需加载的方式。</p>
<p>如果源头数据的数据量不大，就可以采用一次性加载的方式，这种方式最简单，只需在应用启动的时候把源头数据查询出来，依次调用类似上面示例代码中的 put() 方法就可以了。</p>
<p>如果源头数据量非常大，那么就需要按需加载了，按需加载也叫懒加载，指的是只有当应用查询缓存，并且数据不在缓存里的时候，才触发加载源头相关数据进缓存的操作。</p>
<h2 id="实现缓存的按需加载"><a href="#实现缓存的按需加载" class="headerlink" title="实现缓存的按需加载"></a>实现缓存的按需加载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="keyword">final</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();  <span class="keyword">final</span> Lock r = rwl.readLock();  <span class="keyword">final</span> Lock w = rwl.writeLock();   <span class="function">V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;    V v = <span class="keyword">null</span>;    <span class="comment">// 读缓存    r.lock();         ①    try &#123;      v = m.get(key); ②    &#125; finally&#123;      r.unlock();     ③    &#125;    // 缓存中存在，返回    if(v != null) &#123;   ④      return v;    &#125;      // 缓存中不存在，查询数据库    w.lock();         ⑤    try &#123;      // 再次验证      // 其他线程可能已经查询过数据库      v = m.get(key); ⑥      if(v == null)&#123;  ⑦        // 查询数据库        v= 省略代码无数        m.put(key, v);      &#125;    &#125; finally&#123;      w.unlock();    &#125;    return v;   &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果缓存中没有缓存目标对象，那么就需要从数据库中加载，然后写入缓存，写缓存需要用到写锁，所以在代码中的⑤处，我们调用了 <code>w.lock()</code> 来获取写锁。</p>
<p>在获取写锁之后，我们并没有直接去查询数据库，而是在代码⑥⑦处，重新验证了一次缓存中是否存在，再次验证如果还是不存在，我们才去查询数据库并更新本地缓存。</p>
<h2 id="读写锁的升级与降级"><a href="#读写锁的升级与降级" class="headerlink" title="读写锁的升级与降级"></a>读写锁的升级与降级</h2><p>虽然锁的升级是不允许的，但是锁的降级却是允许的。以下代码来源自 ReentrantReadWriteLock 的官方示例，略做了改动。你会发现在代码①处，获取读锁的时候线程还是持有写锁的，这种锁的降级是支持的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;  Object data;  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;  <span class="keyword">final</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();  <span class="comment">// 读锁    final Lock r = rwl.readLock();  // 写锁  final Lock w = rwl.writeLock();    void processCachedData() &#123;    // 获取读锁    r.lock();    if (!cacheValid) &#123;      // 释放读锁，因为不允许读锁的升级      r.unlock();      // 获取写锁      w.lock();      try &#123;        // 再次检查状态          if (!cacheValid) &#123;          data = ...          cacheValid = true;        &#125;        // 释放写锁前，降级为读锁        // 降级是可以的        r.lock(); ①      &#125; finally &#123;        // 释放写锁        w.unlock();       &#125;    &#125;    // 此处仍然持有读锁    try &#123;use(data);&#125;     finally &#123;r.unlock();&#125;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="StampedLock：有没有比读写锁更快的锁？"><a href="#StampedLock：有没有比读写锁更快的锁？" class="headerlink" title="StampedLock：有没有比读写锁更快的锁？"></a>StampedLock：有没有比读写锁更快的锁？</h1><h2 id="StampedLock-支持的三种锁模式"><a href="#StampedLock-支持的三种锁模式" class="headerlink" title="StampedLock 支持的三种锁模式"></a>StampedLock 支持的三种锁模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();  <span class="comment">// 获取 / 释放悲观读锁示意代码long stamp = sl.readLock();try &#123;  // 省略业务相关代码&#125; finally &#123;  sl.unlockRead(stamp);&#125; // 获取 / 释放写锁示意代码long stamp = sl.writeLock();try &#123;  // 省略业务相关代码&#125; finally &#123;  sl.unlockWrite(stamp);&#125;</span></span><br></pre></td></tr></table></figure>

<p>ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。而 StampedLock 支持三种模式，分别是：<strong>写锁</strong>、<strong>悲观读锁</strong>和<strong>乐观读</strong>。其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。</p>
<p>StampedLock 的性能之所以比 ReadWriteLock 还要好，其关键是 StampedLock 支持乐观读的方式。ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。</p>
<p>在 ERP 的生产模块里，会有多个人通过 ERP 系统提供的 UI 同时修改同一条生产订单，那如何保证生产订单数据是并发安全的呢？可以使用乐观锁。</p>
<h2 id="StampedLock-使用注意事项"><a href="#StampedLock-使用注意事项" class="headerlink" title="StampedLock 使用注意事项"></a>StampedLock 使用注意事项</h2><p><strong>StampedLock 的功能仅仅是 ReadWriteLock 的子集</strong></p>
<p><strong>StampedLock 不支持重入</strong></p>
<p>StampedLock 的悲观读锁、写锁都不支持条件变量</p>
<p>如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。**使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()**。</p>
<h1 id="CountDownLatch和CyclicBarrier：如何让多线程步调一致？"><a href="#CountDownLatch和CyclicBarrier：如何让多线程步调一致？" class="headerlink" title="CountDownLatch和CyclicBarrier：如何让多线程步调一致？"></a>CountDownLatch和CyclicBarrier：如何让多线程步调一致？</h1><h2 id="用-CountDownLatch-实现线程等待"><a href="#用-CountDownLatch-实现线程等待" class="headerlink" title="用 CountDownLatch 实现线程等待"></a>用 CountDownLatch 实现线程等待</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 2 个线程的线程池Executor executor = Executors.newFixedThreadPool(2);while(存在未对账订单)&#123;  // 计数器初始化为 2  CountDownLatch latch = new CountDownLatch(2);  // 查询未对账订单  executor.execute(()-&gt; &#123;    pos = getPOrders();    latch.countDown();  &#125;);  // 查询派送单  executor.execute(()-&gt; &#123;    dos = getDOrders();    latch.countDown();  &#125;);    // 等待两个查询操作结束  latch.await();    // 执行对账操作  diff = check(pos, dos);  // 差异写入差异库  save(diff);&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="进一步优化性能"><a href="#进一步优化性能" class="headerlink" title="进一步优化性能"></a>进一步优化性能</h2><p>两次查询操作能够和对账操作并行，对账操作还依赖查询操作的结果，这明显有点生产者 - 消费者的意思，两次查询操作是生产者，对账操作是消费者。既然是生产者 - 消费者模型，那就需要有个队列，来保存生产者生产的数据，而消费者则从这个队列消费数据。</p>
<h2 id="用-CyclicBarrier-实现线程同步"><a href="#用-CyclicBarrier-实现线程同步" class="headerlink" title="用 CyclicBarrier 实现线程同步"></a>用 CyclicBarrier 实现线程同步</h2><p><strong>CountDownLatch 主要用来解决一个线程等待多个线程的场景</strong>，可以类比旅游团团长要等待所有的游客到齐才能去下一个景点；而<strong>CyclicBarrier 是一组线程之间互相等待</strong>，更像是几个驴友之间不离不弃。除此之外 CountDownLatch 的计数器是不能循环利用的，也就是说一旦计数器减到 0，再有线程调用 await()，该线程会直接通过。但<strong>CyclicBarrier 的计数器是可以循环利用的</strong>，而且具备自动重置的功能，一旦计数器减到 0 会自动重置到你设置的初始值。除此之外，CyclicBarrier 还可以设置回调函数，可以说是功能丰富。</p>
<h1 id="并发容器：都有哪些“坑”需要我们填？"><a href="#并发容器：都有哪些“坑”需要我们填？" class="headerlink" title="并发容器：都有哪些“坑”需要我们填？"></a>并发容器：都有哪些“坑”需要我们填？</h1><h2 id="同步容器及其注意事项"><a href="#同步容器及其注意事项" class="headerlink" title="同步容器及其注意事项"></a>同步容器及其注意事项</h2><p>在容器领域<strong>一个容易被忽视的“坑”是用迭代器遍历容器</strong></p>
<p>在容器领域<strong>一个容易被忽视的“坑”是用迭代器遍历容器</strong>，例如在下面的代码中，通过迭代器遍历容器 list，对每个元素调用 foo() 方法，这就存在并发问题，这些组合的操作不具备原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());Iterator i = list.iterator(); <span class="keyword">while</span> (i.hasNext())&#123;    foo(i.next());&#125;</span><br></pre></td></tr></table></figure>

<p>而正确做法是下面这样，锁住 list 之后再执行遍历操作。如果你查看 Collections 内部的包装类源码，你会发现包装类的公共方法锁的是对象的 this，其实就是我们这里的 list，所以锁住 list 绝对是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());<span class="keyword">synchronized</span> (list) &#123;    Iterator i = list.iterator();   <span class="keyword">while</span> (i.hasNext())&#123;      foo(i.next());  &#125;&#125;    </span><br></pre></td></tr></table></figure>

<h2 id="并发容器及其注意事项"><a href="#并发容器及其注意事项" class="headerlink" title="并发容器及其注意事项"></a>并发容器及其注意事项</h2><h3 id="（一）List"><a href="#（一）List" class="headerlink" title="（一）List"></a>（一）List</h3><p>List 里面只有一个实现类就是<strong>CopyOnWriteArrayList</strong>。CopyOnWrite，顾名思义就是写的时候会将共享变量新复制一份出来，这样做的好处是读操作完全无锁。</p>
<p>CopyOnWriteArrayList 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的，如下图所示，迭代器 Iterator 遍历的就是 array 数组。</p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109162351270.png" alt="image-20211109162351270" style="zoom:50%;" />

<p>如果在遍历 array 的同时，还有一个写操作，例如增加元素，CopyOnWriteArrayList 是如何处理的呢？CopyOnWriteArrayList 会将 array 复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将 array 指向这个新的数组。</p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109164605594.png" alt="image-20211109164605594" style="zoom:50%;" />

<p>使用 CopyOnWriteArrayList 需要注意的“坑”主要有两个方面。</p>
<p>一个是应用场景，CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。</p>
<p>另一个需要注意的是，CopyOnWriteArrayList 迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。</p>
<h3 id="（二）Map"><a href="#（二）Map" class="headerlink" title="（二）Map"></a>（二）Map</h3><p>Map 接口的两个实现是 ConcurrentHashMap 和 ConcurrentSkipListMap，它们从应用的角度来看，主要区别在于<strong>ConcurrentHashMap 的 key 是无序的，而 ConcurrentSkipListMap 的 key 是有序的</strong>。</p>
<p>它们的 key 和 value 都不能为空，否则会抛出<code>NullPointerException</code>这个运行时异常。</p>
<table>
<thead>
<tr>
<th align="center">集合类</th>
<th align="center">key</th>
<th align="center">value</th>
<th align="center">是否线程安全</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hashmap</td>
<td align="center">允许为null</td>
<td align="center">允许为null</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">Treemap</td>
<td align="center">不允许为null</td>
<td align="center">允许为null</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">Hashtable</td>
<td align="center">不允许为null</td>
<td align="center">不允许为null</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">ConcurrentHashMap</td>
<td align="center">不允许为null</td>
<td align="center">不允许为null</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">ConcurrentSkipListMap</td>
<td align="center">不允许为null</td>
<td align="center">不允许为null</td>
<td align="center">是</td>
</tr>
</tbody></table>
<p>ConcurrentSkipListMap 里面的 SkipList 本身就是一种数据结构，中文一般都翻译为“跳表”。跳表插入、删除、查询操作平均的时间复杂度是 O(log n)，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若你对 ConcurrentHashMap 的性能还不满意，可以尝试一下 ConcurrentSkipListMap。</p>
<h3 id="（三）Set"><a href="#（三）Set" class="headerlink" title="（三）Set"></a>（三）Set</h3><p>Set 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap</p>
<h3 id="（四）Queue"><a href="#（四）Queue" class="headerlink" title="（四）Queue"></a>（四）Queue</h3><p>Java 并发包里面 Queue 这类并发容器是最复杂的，你可以从以下两个维度来分类。一个维度是<strong>阻塞与非阻塞</strong>，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。另一个维度是<strong>单端与双端</strong>，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。Java 并发包里<strong>阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识</strong>。</p>
<p><strong>四大类</strong></p>
<p>1.<strong>单端阻塞队列</strong>：其实现有 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、LinkedTransferQueue、PriorityBlockingQueue 和 DelayQueue。</p>
<p>内部一般会持有一个队列，这个队列可以是数组（其实现是 ArrayBlockingQueue）也可以是链表（其实现是 LinkedBlockingQueue，其内部对于Node的修改使用CAS操作）；甚至还可以不持有队列（其实现是 SynchronousQueue），此时生产者线程的入队操作必须等待消费者线程的出队操作。</p>
<p>而 LinkedTransferQueue 融合 LinkedBlockingQueue 和 SynchronousQueue 的功能，性能比 LinkedBlockingQueue 更好；PriorityBlockingQueue 支持按照优先级出队；DelayQueue 支持延时出队。</p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109165401099.png" alt="image-20211109165401099" style="zoom:50%;" />

<p>2.<strong>双端阻塞队列</strong>：其实现是 LinkedBlockingDeque。</p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211109165439629.png" alt="image-20211109165439629" style="zoom:50%;" />

<p>3.<strong>单端非阻塞队列</strong>：其实现是 ConcurrentLinkedQueue。<br>4.<strong>双端非阻塞队列</strong>：其实现是 ConcurrentLinkedDeque。</p>
<p>使用队列时，需要格外注意队列是否支持有界（所谓有界指的是内部的队列是否有容量限制）。实际工作中，一般都不建议使用无界的队列，因为数据量大了之后很容易导致 OOM。只有 ArrayBlockingQueue 和 LinkedBlockingQueue 是支持有界的，所以<strong>在使用其他无界队列时，一定要充分考虑是否存在导致 OOM 的隐患</strong>。</p>
<h1 id="原子类：无锁工具类的典范"><a href="#原子类：无锁工具类的典范" class="headerlink" title="原子类：无锁工具类的典范"></a>原子类：无锁工具类的典范</h1><h2 id="无锁方案的实现原理"><a href="#无锁方案的实现原理" class="headerlink" title="无锁方案的实现原理"></a>无锁方案的实现原理</h2><p>CPU 为了解决并发问题，提供了 CAS 指令（CAS，全称是 Compare And Swap，即“比较并交换”）。CAS 指令包含 3 个参数：共享变量的内存地址 A、用于比较的值 B 和共享变量的新值 C；并且只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。<strong>作为一条 CPU 指令，CAS 指令本身是能够保证原子性的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimulatedCAS</span></span>&#123;  <span class="keyword">volatile</span> <span class="keyword">int</span> count;  <span class="comment">// 实现 count+=1  addOne()&#123;    do &#123;      newValue = count+1; //①    &#125;while(count !=      cas(count,newValue) //②  &#125;  // 模拟实现 CAS，仅用来帮助理解  synchronized int cas(    int expect, int newValue)&#123;    // 读目前 count 的值    int curValue = count;    // 比较目前 count 值是否 == 期望值    if(curValue == expect)&#123;      // 如果是，则更新 count 的值      count= newValue;    &#125;    // 返回写入前的值    return curValue;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>只有当目前 count 的值和期望值 expect 相等时，才会将 count 更新为 newValue。</strong></p>
<p>但是在 CAS 方案中，有一个问题可能会常被你忽略，那就是<strong>ABA</strong>的问题。</p>
<h2 id="看-Java-如何实现原子化的-count-1"><a href="#看-Java-如何实现原子化的-count-1" class="headerlink" title="看 Java 如何实现原子化的 count += 1"></a>看 Java 如何实现原子化的 count += 1</h2><p>原子类 AtomicLong 的 getAndIncrement() 方法内部就是基于 CAS 实现的</p>
<p>在 Java 1.8 版本中，getAndIncrement() 方法会转调 unsafe.getAndAddLong() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>); <span class="comment">// this 和 valueOffset 两个参数可以唯一确定共享变量的内存地址&#125;----------------------------------public final long getAndAddLong(Object o, long offset, long delta)&#123;  long v;  do &#123;    // 读取内存中的值    v = getLongVolatile(o, offset);  &#125; while (!compareAndSwapLong(o, offset, v, v + delta));  return v;&#125;// 原子性地将变量更新为 x// 条件是内存中的值等于 expected// 更新成功则返回 truenative boolean compareAndSwapLong(Object o, long offset, long expected, long x);</span></span><br></pre></td></tr></table></figure>

<p>Java 提供的原子类里面 CAS 一般被实现为 compareAndSet()，compareAndSet() 的语义和 CAS 指令的语义的差别仅仅是返回值不同而已，compareAndSet() 里面如果更新成功，则会返回 true，否则返回 false。</p>
<p>模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;  <span class="comment">// 获取当前值  oldV = xxxx；  // 根据当前值计算新值  newV = ...oldV...&#125;while(!compareAndSet(oldV,newV);</span></span><br></pre></td></tr></table></figure>

<h2 id="原子类概览"><a href="#原子类概览" class="headerlink" title="原子类概览"></a>原子类概览</h2><p>Java SDK 并发包里提供的原子类内容很丰富，我们可以将它们分为五个类别：<strong>原子化的基本数据类型、原子化的对象引用类型、原子化数组、原子化对象属性更新器</strong>和<strong>原子化的累加器</strong>。</p>
<h3 id="1-原子化的基本数据类型"><a href="#1-原子化的基本数据类型" class="headerlink" title="1. 原子化的基本数据类型"></a>1. 原子化的基本数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getAndIncrement() <span class="comment">// 原子化 i++getAndDecrement() // 原子化的 i--incrementAndGet() // 原子化的 ++idecrementAndGet() // 原子化的 --i// 当前值 +=delta，返回 += 前的值getAndAdd(delta) // 当前值 +=delta，返回 += 后的值addAndGet(delta)//CAS 操作，返回是否成功compareAndSet(expect, update)// 以下四个方法// 新值可以通过传入 func 函数来计算getAndUpdate(func)updateAndGet(func)getAndAccumulate(x,func)accumulateAndGet(x,func)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-原子化的对象引用类型"><a href="#2-原子化的对象引用类型" class="headerlink" title="2. 原子化的对象引用类型"></a>2. 原子化的对象引用类型</h3><p>相关实现有 AtomicReference、AtomicStampedReference 和 AtomicMarkableReference，利用它们可以实现对象引用的原子化更新。</p>
<h3 id="3-原子化数组"><a href="#3-原子化数组" class="headerlink" title="3. 原子化数组"></a>3. 原子化数组</h3><p>相关实现有 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray，利用这些原子类，我们可以原子化地更新数组里面的每一个元素。</p>
<h3 id="4-原子化对象属性更新器"><a href="#4-原子化对象属性更新器" class="headerlink" title="4. 原子化对象属性更新器"></a>4. 原子化对象属性更新器</h3><p>相关实现有 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater</p>
<h3 id="5-原子化的累加器"><a href="#5-原子化的累加器" class="headerlink" title="5. 原子化的累加器"></a>5. 原子化的累加器</h3><h1 id="Executor与线程池：如何创建正确的线程池？"><a href="#Executor与线程池：如何创建正确的线程池？" class="headerlink" title="Executor与线程池：如何创建正确的线程池？"></a>Executor与线程池：如何创建正确的线程池？</h1><p><strong>线程是一个重量级的对象，应该避免频繁创建和销毁</strong>。 ==&gt; 使用线程池</p>
<h2 id="线程池是一种生产者-消费者模式"><a href="#线程池是一种生产者-消费者模式" class="headerlink" title="线程池是一种生产者 - 消费者模式"></a>线程池是一种生产者 - 消费者模式</h2><p>目前业界线程池的设计，普遍采用的都是<strong>生产者 - 消费者模式</strong>。线程池的使用方是生产者，线程池本身是消费者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的线程池，仅用来说明工作原理class MyThreadPool&#123;  // 利用阻塞队列实现生产者 - 消费者模式  BlockingQueue&lt;Runnable&gt; workQueue;  // 保存内部工作线程  List&lt;WorkerThread&gt; threads = new ArrayList&lt;&gt;();  // 构造方法  public MyThreadPool(int poolSize, BlockingQueue&lt;Runnable&gt; workQueue)&#123;    this.workQueue = workQueue;    // 创建工作线程    for(int idx=0; idx&lt;poolSize; idx++)&#123;      WorkerThread work = new WorkerThread();      work.start();      threads.add(work);    &#125;  &#125;  // 提交任务  public void execute(Runnable command)&#123;    workQueue.put(command);  &#125;  // 工作线程负责消费任务，并执行任务  class WorkerThread extends Thread&#123;    public void run() &#123;      // 循环取任务并执行      while(true)&#123; ①        Runnable task = workQueue.take();        task.run();      &#125;     &#125;  &#125;  &#125; /** 下面是使用示例 **/// 创建有界阻塞队列BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;&gt;(2);// 创建线程池  MyThreadPool pool = new MyThreadPool(10, workQueue);// 提交任务  pool.execute(()-&gt;&#123;    System.out.println(&quot;hello&quot;);&#125;);</span></span><br></pre></td></tr></table></figure>

<h2 id="如何使用-Java-中的线程池"><a href="#如何使用-Java-中的线程池" class="headerlink" title="如何使用 Java 中的线程池"></a>如何使用 Java 中的线程池</h2><p>Java 提供的线程池相关的工具类中，最核心的是<strong>ThreadPoolExecutor</strong>，通过名字你也能看出来，它强调的是 Executor，而不是一般意义上的池化资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(  <span class="keyword">int</span> corePoolSize, <span class="comment">// 核心线程数  int maximumPoolSize, // 最大线程数  long keepAliveTime, // 保持时间  TimeUnit unit, // 保持时间的单位  BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列  ThreadFactory threadFactory, // 创建线程的工厂  RejectedExecutionHandler handler)  // 拒绝策略</span></span><br></pre></td></tr></table></figure>

<p>可以<strong>把线程池类比为一个项目组，而线程就是项目组的成员</strong>。</p>
<ul>
<li><strong>corePoolSize</strong>：表示线程池保有的<strong>最小线程数</strong>。有些项目很闲，但是也不能把人都撤了，至少要留 corePoolSize 个人坚守阵地。</li>
<li><strong>maximumPoolSize</strong>：表示线程池创建的<strong>最大线程数</strong>。当项目很忙时，就需要加人，但是也不能无限制地加，最多就加到 maximumPoolSize 个人。当项目闲下来时，就要撤人了，最多能撤到 corePoolSize 个人。</li>
<li><strong>keepAliveTime &amp; unit</strong>：上面提到项目根据忙闲来增减人员，那在编程世界里，如何定义忙和闲呢？很简单，一个线程如果在一段时间内，都没有执行任务，说明很闲，keepAliveTime 和 unit 就是用来定义这个“一段时间”的参数。也就是说，如果一个线程空闲了<code>keepAliveTime &amp; unit</code>这么久，而且线程池的线程数大于 corePoolSize ，那么这个空闲的线程就要被回收了。</li>
<li><strong>workQueue</strong>：工作队列，和上面示例代码的工作队列同义。</li>
<li><strong>threadFactory</strong>：通过这个参数你可以自定义如何创建线程，例如你可以给线程指定一个有意义的名字。</li>
<li><strong>handler</strong>：通过这个参数你可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。至于拒绝的策略，你可以通过 handler 这个参数来指定。ThreadPoolExecutor 已经提供了以下 4 种策略。<ul>
<li>CallerRunsPolicy：提交任务的线程自己去执行该任务。</li>
<li>AbortPolicy：默认的拒绝策略，会 throws RejectedExecutionException。</li>
<li>DiscardPolicy：直接丢弃任务，没有任何异常抛出。</li>
<li>DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。</li>
</ul>
</li>
</ul>
<h2 id="使用线程池要注意些什么"><a href="#使用线程池要注意些什么" class="headerlink" title="使用线程池要注意些什么"></a>使用线程池要注意些什么</h2><p>Java 并发包里提供了一个线程池的静态工厂类 Executors，利用 Executors 你可以快速创建线程池。不建议使用 Executors 的最重要的原因是：Executors 提供的很多方法默认使用的都是无界的 LinkedBlockingQueue，高负载情境下，无界队列很容易导致 OOM，而 OOM 会导致所有请求都无法处理，这是致命问题。所以<strong>强烈建议使用有界队列</strong>。</p>
<p>线程池默认的拒绝策略会 throw RejectedExecutionException 这是个运行时异常，对于运行时异常编译器并不强制 catch 它，所以开发人员很容易忽略。因此<strong>默认拒绝策略要慎重使用</strong>。</p>
<p>如果线程池处理的任务非常重要，建议自定义自己的拒绝策略；并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。</p>
<p>使用线程池，还要注意<strong>异常处理的问题</strong>，例如通过 ThreadPoolExecutor 对象的 execute() 方法提交任务时，如果任务在执行的过程中出现运行时异常，会导致执行任务的线程终止；不过，最致命的是任务虽然异常了，但是你却获取不到任何通知，这会让你误以为任务都执行得很正常。虽然线程池提供了很多用于异常处理的方法，但是最稳妥和简单的方案还是捕获所有异常并按需处理</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;<span class="comment">// 业务逻辑&#125; catch (RuntimeException x) &#123;// 按需处理&#125; catch (Throwable x) &#123;// 按需处理&#125; </span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Future：如何用多线程实现最优的“烧水泡茶”程序？"><a href="#Future：如何用多线程实现最优的“烧水泡茶”程序？" class="headerlink" title="Future：如何用多线程实现最优的“烧水泡茶”程序？"></a>Future：如何用多线程实现最优的“烧水泡茶”程序？</h1><h2 id="如何获取任务执行结果"><a href="#如何获取任务执行结果" class="headerlink" title="如何获取任务执行结果"></a>如何获取任务执行结果</h2><p>Future 接口有 5 个方法，其中的两个 get() 方法都是阻塞式的，如果被调用的时候，任务还没有执行完，那么调用 get() 方法的线程会阻塞，直到任务执行完才会被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消任务boolean cancel(boolean mayInterruptIfRunning);// 判断任务是否已取消  boolean isCancelled();// 判断任务是否已结束boolean isDone();// 获得任务执行结果，阻塞式方法get();// 获得任务执行结果，支持超时，阻塞式方法get(long timeout, TimeUnit unit);</span></span><br></pre></td></tr></table></figure>

<p>Java 通过 ThreadPoolExecutor 提供的 3 个 submit() 方法和 1 个 FutureTask 工具类来支持获得任务执行结果的需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交 Runnable 任务Future&lt;?&gt; submit(Runnable task);// 提交 Callable 任务&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);// 提交 Runnable 任务及结果引用  &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span></span><br></pre></td></tr></table></figure>

<ol>
<li>提交 Runnable 任务 <code>submit(Runnable task)</code> ：这个方法的参数是一个 Runnable 接口，Runnable 接口的 run() 方法是<strong>没有返回值的</strong>，所以 <code>submit(Runnable task)</code> 这个<strong>方法返回的 Future 仅可以用来断言任务已经结束了</strong>，类似于 Thread.join()。</li>
<li>提交 Callable 任务 <code>submit(Callable&lt;T&gt; task)</code>：这个方法的参数是一个 Callable 接口，它只有一个 call() 方法，并且这个方法是有返回值的，所以<strong>这个方法返回的 Future 对象可以通过调用其 get() 方法来获取任务的执行结果</strong>。</li>
<li>提交 Runnable 任务及结果引用 <code>submit(Runnable task, T result)</code>：这个方法很有意思，假设这个方法返回的 Future 对象是 f，f.get() 的返回值就是传给 submit() 方法的参数 result。</li>
</ol>
<blockquote>
<p>这个方法该怎么用呢？下面这段示例代码展示了它的经典用法。Runnable 接口的实现类 Task 声明了一个有参构造函数 <code>Task(Result r)</code> ，创建 Task 对象的时候传入了 result 对象，这样就能在类 Task 的 run() 方法中对 result 进行各种操作了。result 相当于主线程和子线程之间的桥梁，通过它主子线程可以共享数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);<span class="comment">// 创建 Result 对象 rResult r = new Result();r.setAAA(a);// 提交任务Future&lt;Result&gt; future = executor.submit(new Task(r), r);  Result fr = future.get();// 下面等式成立fr === r;fr.getAAA() === a;fr.getXXX() === xclass Task implements Runnable&#123;Result r;// 通过构造函数传入 resultTask(Result r)&#123; this.r = r;&#125;void run() &#123; // 可以操作 result a = r.getAAA(); r.setXXX(x);&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>FutureTask 工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FutureTask(Callable&lt;V&gt; callable);FutureTask(Runnable runnable, V result);</span><br></pre></td></tr></table></figure>

<p>FutureTask 实现了 Runnable 和 Future 接口，由于实现了 Runnable 接口，所以可以将 FutureTask 对象作为任务提交给 ThreadPoolExecutor 去执行，也可以直接被 Thread 执行；又因为实现了 Future 接口，所以也能用来获得任务的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 FutureTaskFutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(()-&gt; 1+2);// 创建线程池ExecutorService es = Executors.newCachedThreadPool();// 提交 FutureTask es.submit(futureTask);// 获取计算结果Integer result = futureTask.get();</span></span><br></pre></td></tr></table></figure>

<h2 id="实现最优的“烧水泡茶”程序"><a href="#实现最优的“烧水泡茶”程序" class="headerlink" title="实现最优的“烧水泡茶”程序"></a>实现最优的“烧水泡茶”程序</h2><img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211110231109824.png" alt="image-20211110231109824" style="zoom:50%;" />

<p>用两个线程 T1 和 T2 来完成烧水泡茶程序，T1 负责洗水壶、烧开水、泡茶这三道工序，T2 负责洗茶壶、洗茶杯、拿茶叶三道工序，其中 T1 在执行泡茶这道工序时需要等待 T2 完成拿茶叶的工序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T2Task 需要执行的任务:// 洗茶壶、洗茶杯、拿茶叶class T2Task implements Callable&lt;String&gt; &#123;  @Override  String call() throws Exception &#123;    System.out.println(&quot;T2: 洗茶壶...&quot;);    TimeUnit.SECONDS.sleep(1);     System.out.println(&quot;T2: 洗茶杯...&quot;);    TimeUnit.SECONDS.sleep(2);     System.out.println(&quot;T2: 拿茶叶...&quot;);    TimeUnit.SECONDS.sleep(1);    return &quot; 龙井 &quot;;  &#125;&#125;// T1Task 需要执行的任务：// 洗水壶、烧开水、泡茶class T1Task implements Callable&lt;String&gt;&#123;  FutureTask&lt;String&gt; ft2;  // T1 任务需要 T2 任务的 FutureTask  T1Task(FutureTask&lt;String&gt; ft2)&#123;    this.ft2 = ft2;  &#125;  @Override  String call() throws Exception &#123;    System.out.println(&quot;T1: 洗水壶...&quot;);    TimeUnit.SECONDS.sleep(1);        System.out.println(&quot;T1: 烧开水...&quot;);    TimeUnit.SECONDS.sleep(15);    // 阻塞等待，获取 T2 线程的茶叶      String tf = ft2.get();    System.out.println(&quot;T1: 拿到茶叶:&quot;+tf);     System.out.println(&quot;T1: 泡茶...&quot;);    return &quot; 上茶:&quot; + tf;  &#125;&#125;// 创建任务 T2 的 FutureTaskFutureTask&lt;String&gt; ft2 = new FutureTask&lt;&gt;(new T2Task());// 创建任务 T1 的 FutureTaskFutureTask&lt;String&gt; ft1 = new FutureTask&lt;&gt;(new T1Task(ft2));// 线程 T1 执行任务 ft1Thread T1 = new Thread(ft1);T1.start();// 线程 T2 执行任务 ft2Thread T2 = new Thread(ft2);T2.start();// 等待线程 T1 执行结果System.out.println(ft1.get());// 一次执行结果：T1: 洗水壶...T2: 洗茶壶...T1: 烧开水...T2: 洗茶杯...T2: 拿茶叶...T1: 拿到茶叶: 龙井T1: 泡茶...上茶: 龙井</span></span><br></pre></td></tr></table></figure>

<h1 id="CompletableFuture：异步编程没那么难（略）"><a href="#CompletableFuture：异步编程没那么难（略）" class="headerlink" title="CompletableFuture：异步编程没那么难（略）"></a>CompletableFuture：异步编程没那么难（略）</h1><h1 id="CompletionService：如何批量执行异步任务？（略）"><a href="#CompletionService：如何批量执行异步任务？（略）" class="headerlink" title="CompletionService：如何批量执行异步任务？（略）"></a>CompletionService：如何批量执行异步任务？（略）</h1><h1 id="Fork-Join：单机版的MapReduce"><a href="#Fork-Join：单机版的MapReduce" class="headerlink" title="Fork/Join：单机版的MapReduce"></a>Fork/Join：单机版的MapReduce</h1><p><strong>对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。</strong></p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211110232839684.png" style="zoom:50%;" />

<p>并行、聚合、批量并行这三种任务模型，基本上能够覆盖日常工作中的并发场景了，但还是不够全面，因为还有一种“分治”的任务模型没有覆盖到。<strong>分治</strong>，顾名思义，即分而治之，是一种解决复杂问题的思维方法和模式；具体来讲，指的是<strong>把一个复杂的问题分解成多个相似的子问题，然后再把子问题分解成更小的子问题，直到子问题简单到可以直接求解</strong>。理论上来讲，解决每一个问题都对应着一个任务，所以对于问题的分治，实际上就是对于任务的分治。</p>
<p>Java 并发包里提供了一种叫做 Fork/Join 的并行计算框架，就是用来支持分治这种任务模型的。</p>
<h2 id="分治任务模型"><a href="#分治任务模型" class="headerlink" title="分治任务模型"></a>分治任务模型</h2><p>分治任务模型可分为两个阶段：一个阶段是<strong>任务分解</strong>，也就是将任务迭代地分解为子任务，直至子任务可以直接计算出结果；另一个阶段是<strong>结果合并</strong>，即逐层合并子任务的执行结果，直至获得最终结果。</p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211110233203501.png" alt="image-20211110233203501" style="zoom:50%;" />

<h2 id="Fork-Join-的使用"><a href="#Fork-Join-的使用" class="headerlink" title="Fork/Join 的使用"></a>Fork/Join 的使用</h2><p><strong>Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并</strong>。Fork/Join 计算框架主要包含两部分，一部分是<strong>分治任务的线程池 ForkJoinPool</strong>，另一部分是<strong>分治任务 ForkJoinTask</strong>。</p>
<p>ForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask 有两个子类——RecursiveAction 和 RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 RecursiveAction 定义的 compute() 没有返回值，而 RecursiveTask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  <span class="comment">// 1、创建分治任务线程池    ForkJoinPool fjp = new ForkJoinPool(4);  // 2、创建分治任务  Fibonacci fib = new Fibonacci(30);     // 3、启动分治任务    Integer result = fjp.invoke(fib);  // 4、输出结果    System.out.println(result);&#125;// 递归任务static class Fibonacci extends RecursiveTask&lt;Integer&gt;&#123;  final int n;  Fibonacci(int n)&#123;this.n = n;&#125;  protected Integer compute()&#123;    if (n &lt;= 1)return n;    Fibonacci f1 = new Fibonacci(n - 1);    // 创建子任务      f1.fork();    Fibonacci f2 = new Fibonacci(n - 2);    // 等待子任务结果，并合并结果      return f2.compute() + f1.join();  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="ForkJoinPool-工作原理"><a href="#ForkJoinPool-工作原理" class="headerlink" title="ForkJoinPool 工作原理"></a>ForkJoinPool 工作原理</h2><p>Fork/Join 并行计算的核心组件是 ForkJoinPool</p>
<p>ThreadPoolExecutor 本质上是一个生产者 - 消费者模式的实现，内部有一个任务队列，这个任务队列是生产者和消费者通信的媒介；ThreadPoolExecutor 可以有多个工作线程，但是这些工作线程都共享一个任务队列。</p>
<p>ForkJoinPool 本质上也是一个生产者 - 消费者的实现，内部有多个任务队列，ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。</p>
<p>ForkJoinPool 支持一种叫做“<strong>任务窃取</strong>”的机制，如果工作线程对应的任务队列空了，那它可以“窃取”其他工作任务队列里的任务，如此一来，所有的工作线程都不会闲下来了。</p>
<p>ForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。</p>
<img src="https://raw.githubusercontent.com/EdwardLee50/images/master/https://github.com/EdwardLee50/images/image-20211110234033937.png" alt="image-20211110234033937" style="zoom:50%;" />

<h2 id="模拟-MapReduce-统计单词数量"><a href="#模拟-MapReduce-统计单词数量" class="headerlink" title="模拟 MapReduce 统计单词数量"></a>模拟 MapReduce 统计单词数量</h2><p>思路：可以先用二分法递归地将一个文件拆分成更小的文件，直到文件里只有一行数据，然后统计这一行数据里单词的数量，最后再逐级汇总结果。</p>
<p>用一个字符串数组 <code>String[] fc</code> 来模拟文件内容，fc 里面的元素与文件里面的行数据一一对应。关键的代码在 <code>compute()</code> 这个方法里面，这是一个递归方法，前半部分数据 fork 一个递归任务去处理（关键代码 mr1.fork()），后半部分数据则在当前任务中递归处理（mr2.compute()）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  String[] fc = &#123;<span class="string">&quot;hello world&quot;</span>,          <span class="string">&quot;hello me&quot;</span>,          <span class="string">&quot;hello fork&quot;</span>,          <span class="string">&quot;hello join&quot;</span>,          <span class="string">&quot;fork join in world&quot;</span>&#125;;  <span class="comment">// 创建 ForkJoin 线程池      ForkJoinPool fjp = new ForkJoinPool(3);  // 创建任务      MR mr = new MR(fc, 0, fc.length);    // 启动任务      Map&lt;String, Long&gt; result = fjp.invoke(mr);  // 输出结果      result.forEach((k, v)-&gt;System.out.println(k+&quot;:&quot;+v));&#125;//MR 模拟类static class MR extends   RecursiveTask&lt;Map&lt;String, Long&gt;&gt; &#123;  private String[] fc;  private int start, end;  // 构造函数  MR(String[] fc, int fr, int to)&#123;    this.fc = fc;    this.start = fr;    this.end = to;  &#125;  @Override protected   Map&lt;String, Long&gt; compute()&#123;    if (end - start == 1) &#123;      return calc(fc[start]);    &#125; else &#123;      int mid = (start+end)/2;      MR mr1 = new MR(fc, start, mid);      mr1.fork();      MR mr2 = new MR(fc, mid, end);      // 计算子任务，并返回合并的结果          return merge(mr2.compute(),mr1.join());    &#125;  &#125;  // 合并结果  private Map&lt;String, Long&gt; merge(      Map&lt;String, Long&gt; r1,       Map&lt;String, Long&gt; r2) &#123;    Map&lt;String, Long&gt; result = new HashMap&lt;&gt;();    result.putAll(r1);    // 合并结果    r2.forEach((k, v) -&gt; &#123;      Long c = result.get(k);      if (c != null) result.put(k, c+v);      else result.put(k, v);    &#125;);    return result;  &#125;  // 统计单词数量  private Map&lt;String, Long&gt; calc(String line) &#123;    Map&lt;String, Long&gt; result = new HashMap&lt;&gt;();    // 分割单词        String [] words = line.split(&quot;\\s+&quot;);    // 统计单词数量        for (String w : words) &#123;      Long v = result.get(w);      if (v != null) result.put(w, v+1);      else result.put(w, 1L);    &#125;    return result;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/EdwardLee50.github.io/tags/java-%E5%B9%B6%E5%8F%91/" rel="tag"># java,并发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/EdwardLee50.github.io/2020/04/13/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/" rel="prev" title="Java并发摘要笔记（一）">
      <i class="fa fa-chevron-left"></i> Java并发摘要笔记（一）
    </a></div>
      <div class="post-nav-item">
    <a href="/EdwardLee50.github.io/2020/04/16/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/" rel="next" title="Java并发摘要笔记（三）">
      Java并发摘要笔记（三） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lock%E5%92%8CCondition%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9ADubbo%E5%A6%82%E4%BD%95%E7%94%A8%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E8%BD%AC%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">Lock和Condition（下）：Dubbo如何用管程实现异步转同步？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="nav-number">1.1.</span> <span class="nav-text">同步与异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dubbo-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.2.</span> <span class="nav-text">Dubbo 源码分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Semaphore%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E5%99%A8%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">Semaphore：如何快速实现一个限流器？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">信号量模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.2.</span> <span class="nav-text">如何使用信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">快速实现一个限流器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReadWriteLock%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%A4%87%E7%9A%84%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">ReadWriteLock：如何快速实现一个完备的缓存？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98"><span class="nav-number">3.1.</span> <span class="nav-text">快速实现一个缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E7%9A%84%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD"><span class="nav-number">3.2.</span> <span class="nav-text">实现缓存的按需加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E9%99%8D%E7%BA%A7"><span class="nav-number">3.3.</span> <span class="nav-text">读写锁的升级与降级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#StampedLock%EF%BC%9A%E6%9C%89%E6%B2%A1%E6%9C%89%E6%AF%94%E8%AF%BB%E5%86%99%E9%94%81%E6%9B%B4%E5%BF%AB%E7%9A%84%E9%94%81%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">StampedLock：有没有比读写锁更快的锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#StampedLock-%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%89%E7%A7%8D%E9%94%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">StampedLock 支持的三种锁模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StampedLock-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">4.2.</span> <span class="nav-text">StampedLock 使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">CountDownLatch和CyclicBarrier：如何让多线程步调一致？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8-CountDownLatch-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85"><span class="nav-number">5.1.</span> <span class="nav-text">用 CountDownLatch 实现线程等待</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD"><span class="nav-number">5.2.</span> <span class="nav-text">进一步优化性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8-CyclicBarrier-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">5.3.</span> <span class="nav-text">用 CyclicBarrier 实现线程同步</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%EF%BC%9A%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E2%80%9C%E5%9D%91%E2%80%9D%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E5%A1%AB%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">并发容器：都有哪些“坑”需要我们填？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.1.</span> <span class="nav-text">同步容器及其注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.2.</span> <span class="nav-text">并发容器及其注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89List"><span class="nav-number">6.2.1.</span> <span class="nav-text">（一）List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Map"><span class="nav-number">6.2.2.</span> <span class="nav-text">（二）Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89Set"><span class="nav-number">6.2.3.</span> <span class="nav-text">（三）Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Queue"><span class="nav-number">6.2.4.</span> <span class="nav-text">（四）Queue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9A%E6%97%A0%E9%94%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%85%B8%E8%8C%83"><span class="nav-number">7.</span> <span class="nav-text">原子类：无锁工具类的典范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E6%96%B9%E6%A1%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text">无锁方案的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9C%8B-Java-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E5%8C%96%E7%9A%84-count-1"><span class="nav-number">7.2.</span> <span class="nav-text">看 Java 如何实现原子化的 count +&#x3D; 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88"><span class="nav-number">7.3.</span> <span class="nav-text">原子类概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8E%9F%E5%AD%90%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.1.</span> <span class="nav-text">1. 原子化的基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8E%9F%E5%AD%90%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.2.</span> <span class="nav-text">2. 原子化的对象引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8E%9F%E5%AD%90%E5%8C%96%E6%95%B0%E7%BB%84"><span class="nav-number">7.3.3.</span> <span class="nav-text">3. 原子化数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8E%9F%E5%AD%90%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="nav-number">7.3.4.</span> <span class="nav-text">4. 原子化对象属性更新器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8E%9F%E5%AD%90%E5%8C%96%E7%9A%84%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="nav-number">7.3.5.</span> <span class="nav-text">5. 原子化的累加器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Executor%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">Executor与线程池：如何创建正确的线程池？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.1.</span> <span class="nav-text">线程池是一种生产者 - 消费者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Java-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">8.2.</span> <span class="nav-text">如何使用 Java 中的线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="nav-number">8.3.</span> <span class="nav-text">使用线程池要注意些什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Future%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%9C%80%E4%BC%98%E7%9A%84%E2%80%9C%E7%83%A7%E6%B0%B4%E6%B3%A1%E8%8C%B6%E2%80%9D%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">Future：如何用多线程实现最优的“烧水泡茶”程序？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">9.1.</span> <span class="nav-text">如何获取任务执行结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%80%E4%BC%98%E7%9A%84%E2%80%9C%E7%83%A7%E6%B0%B4%E6%B3%A1%E8%8C%B6%E2%80%9D%E7%A8%8B%E5%BA%8F"><span class="nav-number">9.2.</span> <span class="nav-text">实现最优的“烧水泡茶”程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CompletableFuture%EF%BC%9A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%B2%A1%E9%82%A3%E4%B9%88%E9%9A%BE%EF%BC%88%E7%95%A5%EF%BC%89"><span class="nav-number">10.</span> <span class="nav-text">CompletableFuture：异步编程没那么难（略）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CompletionService%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%9F%EF%BC%88%E7%95%A5%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">CompletionService：如何批量执行异步任务？（略）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fork-Join%EF%BC%9A%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84MapReduce"><span class="nav-number">12.</span> <span class="nav-text">Fork&#x2F;Join：单机版的MapReduce</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E4%BB%BB%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">12.1.</span> <span class="nav-text">分治任务模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fork-Join-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">12.2.</span> <span class="nav-text">Fork&#x2F;Join 的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ForkJoinPool-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">12.3.</span> <span class="nav-text">ForkJoinPool 工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F-MapReduce-%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E6%95%B0%E9%87%8F"><span class="nav-number">12.4.</span> <span class="nav-text">模拟 MapReduce 统计单词数量</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EdwardLee50"
      src="/EdwardLee50.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">EdwardLee50</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/EdwardLee50.github.io/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/EdwardLee50.github.io/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/EdwardLee50.github.io/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:EdwardLee50@163.com" title="E-Mail → mailto:EdwardLee50@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EdwardLee50</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/EdwardLee50.github.io/lib/anime.min.js"></script>
  <script src="/EdwardLee50.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/EdwardLee50.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/EdwardLee50.github.io/js/utils.js"></script>

<script src="/EdwardLee50.github.io/js/motion.js"></script>


<script src="/EdwardLee50.github.io/js/schemes/pisces.js"></script>


<script src="/EdwardLee50.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
